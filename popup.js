console.log("üöÄ NovaPet popup.js has started");

// ü§ñ OpenAI ÈÖçÁΩÆ
const OPENAI_API_KEY = ""; // Ë´ãÊõøÊèõÊàê‰Ω†ÁöÑ API Key
const OPENAI_MODEL = "gpt-4o-mini"; // Êàñ‰ΩøÁî® 'gpt-3.5-turbo'

// 1Ô∏è‚É£ Firebase ÂàùÂßãÂåñ
const firebaseConfig = {
  apiKey: "AIzaSyAtCmjIEUK0tH4LI1mdCYAxRu9eqgKOWP4",
  authDomain: "novapet-2b869.firebaseapp.com",
  projectId: "novapet-2b869",
  storageBucket: "novapet-2b869.firebasestorage.app",
  messagingSenderId: "543837261919",
  appId: "1:543837261919:web:0a0f279066b10006950bea",
  measurementId: "G-HBNGMMDKCL",
};

firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();

const PET_PERSONALITIES = {
  dog1: {
    name: "ÁôΩËâ≤ÁãóÁãó",
    personality: "gentle, shy, loyal, loves cuddles and quiet moments",
    personalityZh: "Ê∫´Êüî„ÄÅÂÆ≥Áæû„ÄÅÂø†Ë™†„ÄÅÂñúÊ≠°ÊìÅÊä±ÂíåÂÆâÈùúÊôÇÂÖâ",
  },
  cat1: {
    name: "ÂèØÊÑõË≤ìË≤ì",
    personality:
      "curious, independent, playful at times, enjoys observing and soft naps",
    personalityZh: "Â•ΩÂ•á„ÄÅÁç®Á´ã„ÄÅÂÅ∂ÁàæÊÑõÁé©„ÄÅÂñúÊ≠°ËßÄÂØüÂíåÊüîËªüÁöÑÂçàÁù°",
  },
};
let selectedDogType = "dog1"; // Represents the pet type selected during adoption

// 2Ô∏è‚É£ Â∑•ÂÖ∑ÂáΩÂºè
function showView(id) {
  document.querySelectorAll(".view").forEach((v) => {
    v.classList.remove("active");
  });
  setTimeout(() => {
    const targetView = document.getElementById(id);
    if (targetView) {
      targetView.classList.add("active");
    } else {
      console.error("[Popup] Target view not found:", id);
    }
  }, 50);
}

function genCode() {
  return Math.random().toString(36).slice(2, 8).toUpperCase();
}

function showAlert(message) {
  alert(message);
}

function setButtonLoading(buttonId, isLoading) {
  const btn = document.getElementById(buttonId);
  if (btn) {
    if (isLoading) {
      btn.disabled = true;
      btn.style.opacity = "0.6";
    } else {
      btn.disabled = false;
      btn.style.opacity = "1";
    }
  }
}

function selectDogOption(dogType) {
  selectedDogType = dogType;

  const hiddenInput = document.getElementById("selectedDogType");
  if (hiddenInput) {
    hiddenInput.value = dogType;
  }

  const dogOptions = document.querySelectorAll(".dog-option");
  dogOptions.forEach((opt) => {
    if (opt.getAttribute("data-dog-type") === dogType) {
      opt.classList.add("selected");
    } else {
      opt.classList.remove("selected");
    }
  });
}

// 2.5Ô∏è‚É£ Ëàá content script ÈÄö‰ø°
async function sendMessageToContentScript(action, data = {}) {
  try {
    const [tab] = await chrome.tabs.query({
      active: true,
      currentWindow: true,
    });
    if (!tab || !tab.id) {
      throw new Error("Êâæ‰∏çÂà∞Áï∂ÂâçÊ®ôÁ±§È†Å");
    }
    console.log(`[Popup] üéØ Ê∫ñÂÇôÁôºÈÄÅ ${action} Âà∞Ê®ôÁ±§È†Å ${tab.id}`);

    try {
      const response = await chrome.tabs.sendMessage(tab.id, {
        action,
        ...data,
      });
      console.log(`[Popup] ‚úÖ Ê∂àÊÅØÁôºÈÄÅÊàêÂäü (${action}):`, response);
      return response;
    } catch (firstError) {
      console.warn(
        `[Popup] üìã Á¨¨‰∏ÄÊ¨°ÂòóË©¶ÁôºÈÄÅ ${action} Â§±Êïó: ${firstError.message}. Ê∫ñÂÇôÊ≥®ÂÖ• content script...`
      );
      try {
        await chrome.scripting.executeScript({
          target: { tabId: tab.id },
          files: ["content.js"],
        });
        console.log("[Popup] ‚úÖ Content script Â∑≤Ê≥®ÂÖ•ÔºåÁ≠âÂæÖÂàùÂßãÂåñ...");
        await new Promise((resolve) => setTimeout(resolve, 1000));
        const response = await chrome.tabs.sendMessage(tab.id, {
          action,
          ...data,
        });
        console.log(`[Popup] ‚úÖ ÈáçË©¶ÊàêÂäü (${action}):`, response);
        return response;
      } catch (injectionError) {
        console.error("[Popup] ‚ùå Ê≥®ÂÖ•Â§±Êïó:", injectionError);
        if (
          injectionError.message
            .toLowerCase()
            .includes("cannot access a chrome extension page") ||
          injectionError.message
            .toLowerCase()
            .includes("cannot access chrome:// pages")
        ) {
          showAlert(
            "‚ö†Ô∏è ÁÑ°Ê≥ïÂú®Ê≠§È†ÅÈù¢ÈÅãË°åÂØµÁâ©ÂäüËÉΩÔºÅ\n\nË´ãÂú®‰∏ÄËà¨Á∂≤È†ÅÔºàÂ¶Ç Google„ÄÅYouTubeÔºâ‰∏ä‰ΩøÁî®„ÄÇÁ≥ªÁµ±È†ÅÈù¢ÊàñÊì¥ÂÖÖÂäüËÉΩÈ†ÅÈù¢‰∏çÊîØÊè¥Ê≠§ÂäüËÉΩ„ÄÇ"
          );
        } else {
          showAlert(`ÁÑ°Ê≥ïÊ≥®ÂÖ•ÂØµÁâ©Á®ãÂºèÂà∞Áï∂ÂâçÈ†ÅÈù¢: ${injectionError.message}`);
        }
        throw new Error("ÁÑ°Ê≥ïÊ≥®ÂÖ• content script");
      }
    }
  } catch (error) {
    console.error(`[Popup] ‚ùå ÁôºÈÄÅ ${action} Ê∂àÊÅØÂ§±Êïó:`, error);
    if (error.message.includes("Receiving end does not exist")) {
      showAlert("üîÑ Ë´ãÈáçÊñ∞Êï¥ÁêÜÁ∂≤È†ÅÂæåÂÜçË©¶‰∏ÄÊ¨°ÔºÅ\n\nÂØµÁâ©ÈúÄË¶ÅÈáçÊñ∞Ê∫ñÂÇô‰∏Ä‰∏ã üêæ");
    } else if (
      !error.message.includes("ÁÑ°Ê≥ïÊ≥®ÂÖ• content script") &&
      !error.message.includes("ÁÑ°Ê≥ïÂú®Ê≠§È†ÅÈù¢ÈÅãË°åÂØµÁâ©ÂäüËÉΩ")
    ) {
      showAlert(
        `‚ùå ÁôºÁîüÈåØË™§: ${error.message}\n\nÂª∫Ë≠∞:\n1. ÈáçÊñ∞Êï¥ÁêÜÁ∂≤È†Å\n2. Âú®‰∏ÄËà¨Á∂≤È†Å‰∏ä‰ΩøÁî®\n3. ÈáçÊñ∞ËºâÂÖ•Êì¥ÂÖÖÂäüËÉΩ`
      );
    }
    return null;
  }
}

// 2.6Ô∏è‚É£ Ê™¢Êü•Áï∂ÂâçÈ†ÅÈù¢ÊòØÂê¶Áõ∏ÂÆπ
async function checkPageCompatibility() {
  try {
    const [tab] = await chrome.tabs.query({
      active: true,
      currentWindow: true,
    });
    if (!tab || !tab.url) return false;
    const restrictedPrefixes = [
      "chrome://",
      "chrome-extension://",
      "moz-extension://",
      "edge://",
      "opera://",
      "about:",
      "file://",
      "https://chrome.google.com/webstore",
    ];
    return !restrictedPrefixes.some((prefix) => tab.url.startsWith(prefix));
  } catch (error) {
    console.error("[Popup] Error checking page compatibility:", error);
    return false;
  }
}

// ü§ñ GPT Áõ∏ÈóúÂäüËÉΩ
async function generatePetResponse(userMessage, petName, petType = "dog1") {
  const personality =
    PET_PERSONALITIES[petType]?.personality || "playful and friendly";
  if (!OPENAI_API_KEY || OPENAI_API_KEY === "YOUR_OPENAI_API_KEY_HERE") {
    return getDefaultPetResponse(petType);
  }
  try {
    // ... (fetch to OpenAI - unchanged) ...
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${OPENAI_API_KEY}`,
      },
      body: JSON.stringify({
        model: OPENAI_MODEL,
        messages: [
          {
            role: "system",
            content: `You are a virtual pet named ${petName}. Your personality is ${personality}. Your type is ${
              petType === "cat1" ? "a cat" : "a dog"
            }.
Please respond in a cute pet manner:
- Use sounds appropriate to your type.
- Show love/loyalty (dog) or affection/independence (cat).
- Keep a playful and adorable tone (matching your personality).
- Mention things pets love.
- Keep responses short and emotional (under 50 words).
- Use emojis and action descriptions like *wags tail*, *purrs*.
- IMPORTANT: Always respond in English only, regardless of the user's language.
- IMPORTANT: Stay consistent with your personality.`,
          },
          { role: "user", content: userMessage },
        ],
        temperature: 0.8,
        max_tokens: 100,
        presence_penalty: 0.6,
        frequency_penalty: 0.5,
      }),
    });
    if (!response.ok) throw new Error(`API Error: ${response.status}`);
    const data = await response.json();
    return data.choices[0].message.content;
  } catch (error) {
    console.error("[Popup] ‚ùå OpenAI API Error (generatePetResponse):", error);
    return getDefaultPetResponse(petType);
  }
}

function getDefaultPetResponse(petType = "dog1") {
  const dogResponses = [
    "Woof! That sounds interesting!",
    "Arf arf! I love hearing from you!",
    "*wags tail* You're the best!",
    "Ê±™Ê±™ÔºÅÊàëÂ•ΩÊÑõ‰Ω†ÂñîÔºÅ",
    "*ÊêñÂ∞æÂ∑¥* ÁúüÁöÑÂóéÔºüÂ•ΩÊ£íÂñîÔºÅ",
  ];
  const catResponses = [
    "Meow? Tell me more!",
    "Purrrr... that makes me happy!",
    "Mrow! Thanks for sharing with me!",
    "*rubs against leg*",
    "Purr... I missed you!",
  ];
  const responses = petType === "cat1" ? catResponses : dogResponses;
  return responses[Math.floor(Math.random() * responses.length)];
}

function createTypingIndicator() {
  const indicator = document.createElement("div");
  indicator.className = "message typing-indicator";
  indicator.innerHTML = `
    <div class="dog-avatar-small"></div> 
    <div class="message-content"><span class="typing-dots"><span>.</span><span>.</span><span>.</span></span></div>`;
  return indicator;
}

async function getConversationContext(roomCode, limit = 5) {
  try {
    const snapshot = await db
      .collection("chats")
      .doc(roomCode)
      .collection("messages")
      .orderBy("timestamp", "desc")
      .limit(limit * 2)
      .get();
    const messages = [];
    snapshot.forEach((doc) => {
      const data = doc.data();
      messages.unshift({
        role: data.sender === "user" ? "user" : "assistant",
        content: data.text,
      });
    });
    return messages.slice(-limit * 2);
  } catch (error) {
    console.error("[Popup] Áç≤ÂèñÂ∞çË©±Ê≠∑Âè≤Â§±Êïó:", error);
    return [];
  }
}

async function generatePetResponseWithContext(
  userMessage,
  petName,
  roomCode,
  petType = "dog1"
) {
  const personality =
    PET_PERSONALITIES[petType]?.personality || "playful and friendly";
  if (!OPENAI_API_KEY || OPENAI_API_KEY === "YOUR_OPENAI_API_KEY_HERE") {
    return getDefaultPetResponse(petType);
  }
  try {
    const conversationHistory = await getConversationContext(roomCode, 3);
    const messages = [
      {
        role: "system",
        content: `You are a virtual pet named ${petName}. Your personality is ${personality}. Your type is ${
          petType === "cat1" ? "a cat" : "a dog"
        }.
Respond cute & short (under 50 words, English only). Remember context. Use sounds & actions (*wags tail*).`,
      },
      ...conversationHistory,
      { role: "user", content: userMessage },
    ];
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${OPENAI_API_KEY}`,
      },
      body: JSON.stringify({
        model: OPENAI_MODEL,
        messages,
        temperature: 0.8,
        max_tokens: 100,
      }),
    });
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(
        `API Error: ${response.status} - ${
          errorData.error?.message || "Unknown"
        }`
      );
    }
    const data = await response.json();
    if (data.choices?.[0]?.message) return data.choices[0].message.content;
    throw new Error("Invalid OpenAI response structure.");
  } catch (error) {
    console.error(
      "[Popup] ‚ùå OpenAI API Error (generatePetResponseWithContext):",
      error
    );
    return getDefaultPetResponse(petType);
  }
}

// üÜï ËÅäÂ§©Áõ∏ÈóúÂáΩÂºè
function displayMessage(text, sender, senderName) {
  const messagesContainer = document.getElementById("chatMessages");
  if (!messagesContainer) return;
  const msgEl = document.createElement("div");

  // For pet's avatar in chat, could use currentPetTypeIndicator if available
  const currentPetType =
    document.getElementById("currentPetTypeIndicator")?.value || "dog1";
  const avatarClass =
    sender === "user"
      ? "user-avatar-small"
      : currentPetType === "cat1"
      ? "cat-avatar-small"
      : "dog-avatar-small";

  if (sender === "user") {
    msgEl.className = "message user-typing";
    msgEl.innerHTML = `<div class="${avatarClass}"></div><div class="message-content"><span class="user-name">You</span> ${text}</div>`;
  } else {
    msgEl.className = "message";
    msgEl.innerHTML = `<div class="${avatarClass}"></div><div class="message-content"><span class="pet-name-small">*${
      senderName || "Pet"
    }*</span> ${text}</div>`;
  }
  messagesContainer.appendChild(msgEl);
  messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

async function saveMessageToFirebase(text, sender, senderName) {
  const roomCode = document.getElementById("roomCode")?.textContent;
  if (!roomCode) return;
  try {
    await db.collection("chats").doc(roomCode).collection("messages").add({
      text,
      sender,
      timestamp: firebase.firestore.FieldValue.serverTimestamp(),
      senderName,
    });
    console.log("[Popup] ‚úÖ Ë®äÊÅØÂ∑≤ÂÑ≤Â≠òÂà∞ Firebase");
  } catch (error) {
    console.error("[Popup] ‚ùå ÂÑ≤Â≠òË®äÊÅØÂ§±Êïó:", error);
  }
}

async function loadChatHistory() {
  const roomCode = document.getElementById("roomCode")?.textContent;
  if (!roomCode) return;
  const messagesContainer = document.getElementById("chatMessages");
  if (!messagesContainer) return;
  messagesContainer.innerHTML = "";
  const petName = document.getElementById("userName")?.textContent || "Pet";
  const currentPetType =
    document.getElementById("currentPetTypeIndicator")?.value || "dog1";
  try {
    const snapshot = await db
      .collection("chats")
      .doc(roomCode)
      .collection("messages")
      .orderBy("timestamp", "asc")
      .limit(50)
      .get();
    if (snapshot.empty) {
      const greeting =
        currentPetType === "cat1"
          ? `Meow! I missed you, ${petName}! Let's chat!`
          : `Woof! I missed you, ${petName}! Let's chat!`;
      displayMessage(greeting, "pet", petName);
    } else {
      snapshot.forEach((doc) => {
        const data = doc.data();
        displayMessage(data.text, data.sender, data.senderName);
      });
      console.log(`[Popup] ‚úÖ ËºâÂÖ•‰∫Ü ${snapshot.size} Ê¢ùÊ≠∑Âè≤Ë®äÊÅØ`);
    }
  } catch (error) {
    console.error("[Popup] ‚ùå ËºâÂÖ•ËÅäÂ§©Ë®òÈåÑÂ§±Êïó:", error);
  }
}

let chatListener = null;
function startChatListener() {
  const roomCode = document.getElementById("roomCode")?.textContent;
  if (!roomCode) return;
  if (chatListener) chatListener(); // Unsubscribe previous listener

  chatListener = db
    .collection("chats")
    .doc(roomCode)
    .collection("messages")
    .orderBy("timestamp", "desc")
    .limit(1)
    .onSnapshot(
      (snapshot) => {
        snapshot.docChanges().forEach((change) => {
          if (change.type === "added") {
            const data = change.doc.data();
            const messagesContainer = document.getElementById("chatMessages");
            if (!messagesContainer) return;
            const lastMsgContentEl = messagesContainer.querySelector(
              ".message:last-child .message-content"
            );
            // A more robust check to avoid duplicate display, especially for self-sent messages via listener
            if (
              lastMsgContentEl &&
              lastMsgContentEl.textContent.includes(data.text) &&
              ((data.sender === "user" &&
                lastMsgContentEl.querySelector(".user-name")) ||
                (data.sender !== "user" &&
                  lastMsgContentEl
                    .querySelector(".pet-name-small")
                    ?.textContent.includes(data.senderName)))
            ) {
              console.log(
                "[Popup] Skipping duplicate message from listener:",
                data.text
              );
              return;
            }
            displayMessage(data.text, data.sender, data.senderName);
          }
        });
      },
      (error) => console.error("[Popup] ‚ùå Ë®äÊÅØÁõ£ËÅΩÈåØË™§:", error)
    );
}

function stopChatListener() {
  if (chatListener) {
    chatListener();
    chatListener = null;
  }
}

async function sendMessage() {
  const input = document.getElementById("chatInput");
  if (!input) return;
  const message = input.value.trim();
  if (!message) return;

  const userName = document.getElementById("userName")?.textContent || "User";
  const petName = userName; // Pet's name is user's name
  const roomCode = document.getElementById("roomCode")?.textContent;
  if (!roomCode) return;

  const storageData = await chrome.storage.local.get(["petType"]);
  const currentPetType = storageData.petType || "dog1";

  displayMessage(message, "user", "You"); // Display user's message
  await saveMessageToFirebase(message, "user", userName); // Save user's message
  input.value = "";

  const typingIndicator = createTypingIndicator();
  const messagesContainer = document.getElementById("chatMessages");
  if (!messagesContainer) return;
  messagesContainer.appendChild(typingIndicator);
  messagesContainer.scrollTop = messagesContainer.scrollHeight;

  try {
    const aiResponse = await generatePetResponseWithContext(
      message,
      petName,
      roomCode,
      currentPetType
    );
    typingIndicator.remove();
    displayMessage(aiResponse, "pet", petName); // Display AI's response
    await saveMessageToFirebase(aiResponse, "pet", petName); // Save AI's response
  } catch (error) {
    console.error("[Popup] ÁîüÊàêÂõûÊáâÊôÇÁôºÁîüÈåØË™§:", error);
    typingIndicator.remove();
    const defaultResponse = getDefaultPetResponse(currentPetType);
    displayMessage(defaultResponse, "pet", petName);
    await saveMessageToFirebase(defaultResponse, "pet", petName);
  }
}

function renderAvatarFromData(data) {
  console.log("[renderAvatarFromData] Êî∂Âà∞ data:", data);

  // Â¶ÇÊûúÊúâ roomCodeÔºåË°®Á§∫Â∑≤Á∂ìÊúâÈ†òÈ§äÁ¥ÄÈåÑ ‚Üí È°ØÁ§∫ÊàøÈñì
  if (data.roomCode) {
    // 1Ô∏è‚É£ Â°´ roomCode / userName Âà∞Â∞çÊáâÂÖÉÁ¥†
    const roomCodeEl = document.getElementById("roomCode");
    const userNameEl = document.getElementById("userName");
    const petAvatarEl = document.getElementById("petAvatar");

    // Â¶ÇÊûúÂÖÉÁ¥†Â≠òÂú®ÔºåÂ∞±ÊääÊñáÂ≠óÂ°û‰∏äÂéª
    if (roomCodeEl) roomCodeEl.textContent = data.roomCode;
    if (userNameEl) userNameEl.textContent = data.userName || "Guest";

    const petTypeFromStorage = data.petType || "dog1";
    console.log(
      "[renderAvatarFromData] Effective petType for avatar:",
      petTypeFromStorage
    );

    // 2Ô∏è‚É£ Êää petAvatarEl Ë£°Èù¢ÂÖàÊ∏ÖÊéâ
    if (petAvatarEl) {
      petAvatarEl.innerHTML = "";
      console.log("[renderAvatarFromData] Cleared petAvatarEl.innerHTML");

      // 3Ô∏è‚É£ Âª∫Á´ã <img>ÔºåÊ†πÊìö petType ‰æÜÊ±∫ÂÆö src
      const petIconImg = document.createElement("img");
      console.log(
        "[renderAvatarFromData] Created img element for room avatar:",
        petIconImg
      );

      let imgSrc = "";
      if (petTypeFromStorage === "dog1") {
        imgSrc = "images/Dog_happy.png";
      } else if (petTypeFromStorage === "cat1") {
        imgSrc = "images/Cat_happy.png";
      } else {
        imgSrc = "images/Dog_happy.png"; // Default fallback
      }
      console.log(
        "[renderAvatarFromData] Setting room avatar img src to:",
        imgSrc
      );

      // Ë®≠ÂÆö <img> ÁöÑ src + Ê®£Âºè
      petIconImg.src = imgSrc;
      petIconImg.style.display = "block";
      petIconImg.style.width = "100%";
      petIconImg.style.height = "100%";
      petIconImg.style.objectFit = "contain";

      // onload / onerror Ë®≠ÂÆöÔºàÊñπ‰æøÂÅµÈåØ & fallbackÔºâ
      petIconImg.onload = function () {
        console.log(
          "[renderAvatarFromData] Room avatar image LOADED successfully:",
          this.src
        );
      };
      petIconImg.onerror = function () {
        console.error(
          "[renderAvatarFromData] Room avatar image FAILED to load:",
          this.src
        );
        petAvatarEl.textContent = petTypeFromStorage === "cat1" ? "üò∫" : "üêï";
        Object.assign(petAvatarEl.style, {
          fontSize: "50px",
          lineHeight: petAvatarEl.clientHeight + "px" || "120px",
          textAlign: "center",
          color: "white",
        });
      };

      // Êää <img> Âä†ÂõûÂà∞ #petAvatar Ë£°
      petAvatarEl.appendChild(petIconImg);
      console.log(
        "[renderAvatarFromData] Appended room avatar img. Current petAvatarEl.innerHTML:",
        petAvatarEl.innerHTML
      );
    } else {
      console.error(
        "[renderAvatarFromData] ERROR: petAvatarEl not found in DOM for setting image!"
      );
    }

    // 4Ô∏è‚É£ Âª∫ÔºèÊõ¥Êñ∞‰∏ÄÂÄãÈö±Ëóè inputÔºå‰æõÂÖ∂‰ªñÁ®ãÂºèËÆÄÂèñ„ÄåÁõÆÂâç petType„Äç
    let currentPetTypeIndicator = document.getElementById(
      "currentPetTypeIndicator"
    );
    if (!currentPetTypeIndicator) {
      currentPetTypeIndicator = document.createElement("input");
      currentPetTypeIndicator.type = "hidden";
      currentPetTypeIndicator.id = "currentPetTypeIndicator";
      document.body.appendChild(currentPetTypeIndicator);
    }
    currentPetTypeIndicator.value = petTypeFromStorage;

    // 5Ô∏è‚É£ ÊúÄÂæåÂàáÂà∞ view-room
    showView("view-room");
    console.log("[renderAvatarFromData] Called showView('view-room')");
  } else {
    // Â¶ÇÊûúÊ≤íÊúâ roomCodeÔºå‰ª£Ë°®Â∞öÊú™È†òÈ§ä ‚Üí È°ØÁ§∫„ÄåÈ†òÈ§äÔºèÂàùÂßãÂåñÁï´Èù¢„ÄçÔºàview-init / view-adoptÔºâ
    console.log(
      "[renderAvatarFromData] No roomCode in data. Showing view-init."
    );
    showView("view-init");
  }
}

// 3Ô∏è‚É£ DOMContentLoaded ‰∏≠Á∂ÅÂÆöÊâÄÊúâ‰∫ã‰ª∂
document.addEventListener("DOMContentLoaded", () => {
  console.log("üéØ DOM ËºâÂÖ•ÂÆåÊàê");

  const dogOptions = document.querySelectorAll(".dog-option");
  dogOptions.forEach((opt) => {
    opt.addEventListener("click", () => {
      const dt = opt.getAttribute("data-dog-type");
      selectDogOption(dt);
    });
  });

  const viewAdopt = document.getElementById("view-adopt");
  if (viewAdopt && viewAdopt.classList.contains("active")) {
    selectDogOption("dog1");
  }

  setTimeout(() => {
    const loadingOverlay = document.getElementById("loadingOverlay");
    if (loadingOverlay) loadingOverlay.classList.add("hidden");
    document.body.classList.remove("loading");
  }, 200);

  chrome.storage.local.get(["roomCode", "userName", "petType"], (data) => {
    console.log("[Popup] Storage data retrieved on DOMContentLoaded:", data);
    renderAvatarFromData(data);
  });

  // Donate button events
  document.getElementById("btnDonate")?.addEventListener("click", () => {
    showView("view-donate"); /* ... (rest of donate logic unchanged) ... */
  });
  document
    .getElementById("btnBackFromDonate")
    ?.addEventListener("click", () => showView("view-room"));
  let selectedDonationAmount = 0;
  document.querySelectorAll(".amount-btn").forEach((btn) => {
    btn.addEventListener("click", () => {
      /* ... (rest of amount selection unchanged) ... */
      document
        .querySelectorAll(".amount-btn")
        .forEach((b) => b.classList.remove("selected"));
      btn.classList.add("selected");
      selectedDonationAmount = parseInt(btn.dataset.amount);
      const selAmtEl = document.getElementById("selectedAmount");
      if (selAmtEl) selAmtEl.textContent = `$${selectedDonationAmount}`;
      const subBtn = document.getElementById("btnSubmitDonate");
      if (subBtn) subBtn.classList.add("active");
    });
  });
  document.getElementById("btnSubmitDonate")?.addEventListener("click", () => {
    if (selectedDonationAmount > 0) {
      /* ... (rest of submit unchanged) ... */
      showAlert(`Thank you for your $${selectedDonationAmount} donation! ...`);
      setTimeout(() => showView("view-room"), 100);
    }
  });

  // Navigation buttons
  document.getElementById("btnNew")?.addEventListener("click", () => {
    chrome.storage.local.remove(["roomCode", "userName", "petType"]);
    const adoptNameEl = document.getElementById("adoptName");
    if (adoptNameEl) adoptNameEl.value = "";
    selectDogOption("dog1");
    showView("view-adopt");
  });
  document.getElementById("btnExisting")?.addEventListener("click", () => {
    const enterCodeEl = document.getElementById("enterCode");
    if (enterCodeEl) enterCodeEl.value = "";
    showView("view-enter");
  });
  document
    .getElementById("btnBackFromAdopt")
    ?.addEventListener("click", () => showView("view-init"));
  document
    .getElementById("btnBackFromEnter")
    ?.addEventListener("click", () => showView("view-init"));

  // Chat buttons
  document.getElementById("btnChat")?.addEventListener("click", async () => {
    showView("view-chat");
    await loadChatHistory();
    startChatListener();
  });
  document.getElementById("btnCloseChat")?.addEventListener("click", () => {
    stopChatListener();
    showView("view-room");
  });
  document.getElementById("btnSend")?.addEventListener("click", sendMessage);
  document.getElementById("chatInput")?.addEventListener("keypress", (e) => {
    if (e.key === "Enter") sendMessage();
  });

  // Pet action buttons
  const actionButtons = document.querySelectorAll(
    ".action-btn:not(#btnChat):not(#btnDonate)"
  );
  actionButtons.forEach((btn) => {
    btn.addEventListener("click", async () => {
      const action = btn.textContent.trim();
      await handlePetAction(action);
    });
  });

  // Invite button
  const inviteBtn = document.querySelector(".header-btn:not(#btnExit)");
  if (inviteBtn) {
    inviteBtn.addEventListener("click", () => {
      /* ... (invite logic unchanged) ... */
      const roomCode = document.getElementById("roomCode")?.textContent;
      if (!roomCode) {
        showAlert("ÁÑ°Ê≥ïÁç≤ÂèñÊàøÈñìÁ¢º„ÄÇ");
        return;
      }
      const message = `Join my NovaPet space!\nRoom code: ${roomCode}`;
      if (navigator.clipboard) {
        navigator.clipboard
          .writeText(roomCode)
          .then(() => showAlert("ÊàøÈñìÁ¢ºÂ∑≤Ë§áË£Ω!"))
          .catch(() => showAlert(message));
      } else {
        showAlert(message);
      }
    });
  }
});

// 4Ô∏è‚É£ È†òÈ§äÊñ∞ÂØµÁâ©
document.getElementById("btnAdopt")?.addEventListener("click", async () => {
  const nameInput = document.getElementById("adoptName");
  if (!nameInput) return;
  const name = nameInput.value.trim();
  if (!name) {
    showAlert("Ë´ãËº∏ÂÖ•‰Ω†ÁöÑÂêçÂ≠ó");
    return;
  }
  if (!selectedDogType) {
    showAlert("Ë´ãÂÖàÈÅ∏Êìá‰Ω†Ë¶ÅÈ†òÈ§äÁöÑÂØµÁâ©ÔºÅ");
    return;
  }

  setButtonLoading("btnAdopt", true);
  const code = genCode();
  try {
    const cred = await auth.signInAnonymously();
    await db.collection("rooms").doc(code).set({
      owner: cred.user.uid,
      name,
      petType: selectedDogType,
      happiness: 30,
      stars: 152,
      notifications: 4,
      createdAt: firebase.firestore.FieldValue.serverTimestamp(),
    });

    const userNameEl = document.getElementById("userName");
    if (userNameEl) userNameEl.textContent = name;
    const roomCodeEl = document.getElementById("roomCode");
    if (roomCodeEl) roomCodeEl.textContent = code;

    chrome.storage.local.set(
      {
        roomCode: code,
        userName: name,
        petType: selectedDogType,
      },
      () => {
        console.log("[Popup] ‚úÖ Â∑≤ÂÑ≤Â≠ò roomCode, userName, petType Âà∞ Storage");
        // ÂÜçËÆÄ‰∏ÄÊ¨° StorageÔºåÊää avatar„ÄÅÊñáÂ≠ó‰∏ÄÊ¨° render ÂÆåÂÖ®
        chrome.storage.local.get(
          ["roomCode", "userName", "petType"],
          (data) => {
            renderAvatarFromData(data);
          }
        );
      }
    );
    console.log("[Popup] ‚úÖ ÊàøÈñìÂâµÂª∫ÊàêÂäü:", code);
  } catch (error) {
    console.error("[Popup] ‚ùå ÂâµÂª∫ÊàøÈñìÂ§±Êïó:", error);
    showAlert("ÂâµÂª∫ÊàøÈñìÂ§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶");
  } finally {
    setButtonLoading("btnAdopt", false);
  }
});

// 5Ô∏è‚É£ Âä†ÂÖ•ÁèæÊúâÊàøÈñì
document.getElementById("btnEnter")?.addEventListener("click", async () => {
  const codeInput = document.getElementById("enterCode");
  if (!codeInput) return;
  const code = codeInput.value.trim().toUpperCase();
  if (!code) {
    showAlert("Ë´ãËº∏ÂÖ•ÊàøÈñìÁ¢º");
    return;
  }

  setButtonLoading("btnEnter", true);
  try {
    // const cred = await auth.signInAnonymously(); // Not strictly needed if just joining
    const roomDoc = await db.collection("rooms").doc(code).get();
    if (!roomDoc.exists) {
      showAlert("ÊàøÈñì‰∏çÂ≠òÂú®ÔºåË´ãÊ™¢Êü•ÊàøÈñìÁ¢º");
      setButtonLoading("btnEnter", false);
      return;
    }
    const roomData = roomDoc.data();
    const name = roomData.name || "Guest";
    const petTypeFromDB = roomData.petType || "dog1";

    const roomCodeEl = document.getElementById("roomCode");
    if (roomCodeEl) roomCodeEl.textContent = code;
    const userNameEl = document.getElementById("userName");
    if (userNameEl) userNameEl.textContent = name;

    // 3. ÂØ´ÂÖ• storageÔºå‰∏¶Âú® callback ‰∏≠ÂëºÂè´ renderAvatarFromData() ‚Üí ÊâçÁúüÊ≠£Êää avatar Â°ûÈÄ≤Âéª
    chrome.storage.local.set(
      {
        roomCode: code,
        userName: name,
        petType: petTypeFromDB,
      },
      () => {
        console.log("[Popup] ‚úÖ Â∑≤Â∞á roomCode, userName, petType Â≠òÈÄ≤ storage");
        // 4. ËÆÄÂá∫ storage Ë£°ÁöÑÊñ∞ÂÄº‰∏¶Ê∏≤Êüì avatar ËàáÊñáÂ≠óÔºåÂÜçÂàáÂà∞ view-room
        chrome.storage.local.get(
          ["roomCode", "userName", "petType"],
          (data) => {
            renderAvatarFromData(data);
            console.log(
              "[Popup] ‚úÖ renderAvatarFromData Â∑≤Âü∑Ë°åÔºåÁï´Èù¢ÂàáÂà∞ view-room"
            );
          }
        );
      }
    );
    // Ë®ªÔºö‰∏çË¶ÅÂÜçÂØ´ showView("view-room")ÔºåÂõ†ÁÇ∫ renderAvatarFromData Ë£°Â∑≤Á∂ìÂåÖÂê´‰∫Ü showView
    // console.log("[Popup] ‚úÖ ÊàêÂäüÂä†ÂÖ•ÊàøÈñì:", code);
  } catch (error) {
    console.error("[Popup] ‚ùå Âä†ÂÖ•ÊàøÈñìÂ§±Êïó:", error);
    showAlert("Âä†ÂÖ•ÊàøÈñìÂ§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶");
  } finally {
    setButtonLoading("btnEnter", false);
  }
});

// 6Ô∏è‚É£ ÈÄÄÂá∫ÊàøÈñì
document.getElementById("btnExit")?.addEventListener("click", async () => {
  const roomCode = document.getElementById("roomCode")?.textContent;
  const confirmMessage = `Are you sure? You will need the space name to come back.\n\nSpace code: ${
    roomCode || "N/A"
  }`;

  if (confirm(confirmMessage)) {
    try {
      console.log("[Popup] üêæ Ê≠£Âú®ÁßªÈô§ÂØµÁâ©...");
      const removeResult = await sendMessageToContentScript("REMOVE_DOG");
      if (removeResult?.success)
        console.log("[Popup] ‚úÖ ÂØµÁâ©Â∑≤ÊàêÂäüÁßªÈô§ (from content script)");
      else console.warn("[Popup] ‚ö†Ô∏è ÁßªÈô§ÂØµÁâ©ÂèØËÉΩÂ§±ÊïóÊàñÊú™Êî∂Âà∞Á¢∫Ë™ç");
    } catch (error) {
      console.error("[Popup] ‚ùå ÁßªÈô§ÂØµÁâ©ÊôÇÁôºÁîüÈåØË™§:", error);
    }
    stopChatListener();
    chrome.storage.local.remove(["roomCode", "userName", "petType"], () => {
      console.log("[Popup] ‚úÖ Â∑≤ÈÄÄÂá∫ÊàøÈñìÔºåÊ∏ÖÈô§localStorage");
      const roomCodeEl = document.getElementById("roomCode");
      if (roomCodeEl) roomCodeEl.textContent = "";
      const userNameEl = document.getElementById("userName");
      if (userNameEl) userNameEl.textContent = "";
      const petAvatarEl = document.getElementById("petAvatar");
      if (petAvatarEl) petAvatarEl.innerHTML = "";
      showView("view-init");
    });
  }
});

// 7Ô∏è‚É£ ÂØµÁâ©Âãï‰ΩúËôïÁêÜ
async function handlePetAction(actionText) {
  const userName = document.getElementById("userName")?.textContent || "Pet";
  console.log(`[Popup] üêæ Âü∑Ë°åÂãï‰Ωú: ${actionText} for ${userName}`);

  const isCompatible = await checkPageCompatibility();
  if (!isCompatible) {
    showAlert("‚ö†Ô∏è Ê≠§È†ÅÈù¢‰∏çÊîØÊè¥ÂØµÁâ©ÂäüËÉΩÔºÅ...\n");
    return;
  }

  let actionToSend;
  // let alertMessage = ""; // Alert handled by content script or not at all

  switch (actionText) {
    case "Go out for a walk":
      actionToSend = "START_WALKING";
      break;
    // Add other cases like 'Feed', 'Treat', 'Toy' if you have dedicated buttons for them
    // For now, these actions are primarily triggered from content.js's control panel
    default:
      showAlert(`${actionText} ÂäüËÉΩÈñãÁôº‰∏≠...`);
      return;
  }

  if (actionToSend) {
    const storageData = await chrome.storage.local.get(["petType"]);
    const currentPetType = storageData.petType || "dog1";
    const petPersonality = PET_PERSONALITIES[currentPetType]?.personality;

    const result = await sendMessageToContentScript(actionToSend, {
      dogName: userName, // This is passed as pet's name to content script
      personality: petPersonality,
      // petType: currentPetType // Optionally pass petType if content script needs it for this action
    });

    if (result?.success)
      console.log(`[Popup] ${actionToSend} ÊàêÂäü:`, result.message || "OK");
    else
      console.warn(
        `[Popup] ${actionToSend} ÂèØËÉΩÂ§±Êïó:`,
        result?.message || "No confirmation"
      );
  }
}

// 8Ô∏è‚É£ ÂÖ®Â±ÄÈåØË™§ËôïÁêÜ & Âç∏ËºâÊôÇËôïÁêÜ
window.addEventListener("error", (event) => {
  console.error(
    "[Popup] ‚ùå ÂÖ®Â±ÄÈåØË™§:",
    event.error,
    event.message,
    event.filename,
    event.lineno
  );
});
window.addEventListener("unhandledrejection", (event) => {
  console.error("[Popup] ‚ùå Êú™ËôïÁêÜÁöÑ Promise Rejection:", event.reason);
});
window.addEventListener("beforeunload", () => {
  stopChatListener();
});

// üîü Firebase ÈáçÂïüÈÄ£Á∑ö
firebase
  .firestore()
  .enableNetwork()
  .then(() => console.log("[Popup] ‚úÖ Firebase Á∂≤Ë∑ØÂ∑≤ÂïüÁî®"))
  .catch((error) => console.error("[Popup] ‚ùå Firebase ÂïüÁî®Á∂≤Ë∑ØÂ§±Êïó:", error));
